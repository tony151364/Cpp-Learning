- C++自带了一个包含函数的大型库（标准ANSI库加上多个C++类），但真正的编程乐趣在于编写自己的函数

## 7.1 复习函数的基本知识
- 要使用C++函数，必须：
  - 提供函数定义；
  - 提供函数原型；
  - 调用函数； 

### 7.1.1 定义函数
- 可以将函数分为两类：
```C++
// 1.没有返回值的函数(void)
void funtionName(parameterList)  // parameter指定了传递给函数的参数类型和数量
{
    statement(s);
    return;  // 可选的,返回语句标记了函数的结尾
}
// 2.有返回值的函数
typeName funtionName(parameterList)
{
    statement(s);
    return value;  // 必须有返回语句
}
```
- 返回值：除了数组，可以是任何类型，包括指针、结构、对象！虽然不能直接返回数组，但是可以将数组作为结构或对象的组成部分来返回。

```C++
#include <iostream>
using namespace std;
void cheers(int);
double cube(double x);

int main()
{
	cheers(5);  // function call
	cout << "Give me a number: ";
	double side;
	cin >> side;
	double volume = cube(side);  // function call
	cout << "A " << side << "-foot cube has a volume of ";
	cout << volume << " cubic feet.\n";
	cheers(cube(2));  // prototype protection at work
	return 0;
}

void cheers(int n)
{
	for (int i = 0; i < n; ++i)
		cout << "Cheers! ";
	cout << endl;
}

double cube(double x)
{
	// 返回语句使用了一个表达式，函数将计算该表达式的值，并将其返回
	return x * x * x;
}
```
- 函数原型将返回值类型告知调用程序，而函数定义命令被调用函数应返回什么类型的数据。
- [ ] **在原型中提供与定义中相同的信息似乎有些多余**，但这样做确实有些道理。要让信差从办公室的办公桌取走一些物品，则向信差和办公室中的同事交代自己的意图，将提高信差顺利完成这样工作的概率。(需要仔细揣摩一下, 结合图7.1)（原型给调用函数的人提出意见，定义给函数本身提供协助）

#### 1.为什么需要原型
- 原型描述了函数到编译器的接口，，它将函数返回值的类型以及参数的类型告诉编译器
  - 参数类型：当参数类型不对，或者没有提供时，编译器能捕获这种错误。
  - 返回值类型：知道了返回值类型，如double，编译器才知道应该检索多少个字节以及如何解释它们。
- 难道编译器不能自己在文件中自己查找，了解函数是如何定义的吗？
  - 问题1：效率不高。编译器在搜索文件的剩余部分时将必须停止对main()的编译。
  - 问题2：函数可能不在当前文件中。C++允许将一个程序放在多个文件中，单独编译这些文件，然后再将它们组合起来。在这种情况下，编译器在编译main()时，可能无权访问函数代码。如果函数位于库中，情况也将如此。
- 避免使用函数原型的唯一方法：在首次使用函数之前定义它，但这并不是总是可行的。而且，C++的编程风格是将main()放在最前面，因为它通常提供了程序的整体结构。

#### 2.原型的语法
- 原型是一条语句，因此必须以分号结束。获得原型最简单的方法是：复制函数定义中的函数头，并添加分号。
- 函数原型不要求提供变量名，但是也可以包括。原型中的变量名相当于占位符，因此不必与函数定义中的变量名相同。
#### C++原型与ANSI原型
- 在C++中，括号为空与在括号中使用关键字void是等效的——意味着函数没有参数。
- 在ANSI C中，括号为空意味着不指出参数——这意味着将在后面定义参数列表。
- C++中，不指定参数列表是应使用省略号：``` void say_bye(...); ```

#### 3.原型的功能
- 功能：
  - 编译器正确处理函数返回值
  - 编译器检查使用的参数数目是否正确
  - 编译器检查使用的参数类型是否正确。如果不正确，则转换为正确的类型（如果可能的话）
- 在C++中，原型不是可选的。
- C++自动将传递的值转换为原型中指定的类型，条件是两者都是算术类型。``` cheers(cube(2)) ```
- 通常，原型自动将被传递的参数强制转换为期望的类型。（但第8章将介绍的函数重载可能导致二义性，因此不允许某些自动强制类型转换）
- 较大的类型转换为较小的类型时，有些编译器将发出警告，指出这可能会丢失数据。
- 仅当有意义时，原型化才会导致类型转换。例如，原型不会将整数转换为结构或指针。
- 在编译阶段进行的原型化被称为静态类型检查(static type checking)。可以看出，静态类型检查可捕获许多在运行阶段非常难以捕获的错误。

## 7.2 



















