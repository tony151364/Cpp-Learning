## [类与对象](https://www.bilibili.com/video/BV1jm4y1w7pa)

### 103.简单使用类
- 1.在类中使用枚举，作用域是整个类
- 2.在实际开发中，用结构体描述纯粹的数据，用类描述对象
- 3.在类的声明中定义的函数都将自动成为内联函数

### 104.构造函数和析构函数
- 1.在构造函数名后面加括号和参数不是调用构造函数，是创建匿名对象。
- 2.以下两行代码有本质区别：
```C++
CGirl girl = CGirl("西施", 20);  // 显式创建对象

// 一共创建了两个对象
CGirl girl;               // 创建对象
girl = CGirl("西施", 20);  // 创建匿名对象，然后给现有的对象赋值
```
- 3.用 new/delete 创建/销毁 对象时，也会调用 构造/析构 函数
- 4.不建议在 构造/析构 函数中写太多的代码，因为很多代码都是重复的，这时候可以把这些重复的代码放到一个成员函数（如：initData()）中，然后在构造函数中调用该成员函数。
- 5.除了初始化，不建议让构造函数做太多的工作，一般只作一些“只会成功不会失败”的工作。因为没有返回值，无法知道它的调用结果，所以复杂的工作交给它不太合适。
- 6.C++11 支持统一初始化列表
```C++
CGirl girl {"西施", 20}; 
CGirl girl= CGirl("西施", 20);
CGirl* girl =  new CGirl{"西施", 20};
```
- 7.如果类的成员也是类，创建对象时，先构造成员类；销毁对象时，先析构成员类

### 105.拷贝构造函数
- 在C++中，用一个已存在的对象创建新的对象，不会调用（普通）构造函数，而是调用拷贝构造函数。如果类中没有定义拷贝构造函数，编译器将提供一个拷贝构造函数，它的功能是把已存在对象的成员变量赋值给新对象的成员变量。
```C++
类名(const 类名& value)
CGirl(const CGirl& girl)
{
  m_name = 漂亮的+gg.m_name;
  m_age = gg.m_age - 1;
  cout << "..." << endl;
}
```
- 以值传递的方式调用函数时，如果实参为对象，调用拷贝构造函数(形参 = 实参）
- **函数以值的方式返回对象时，可能会调用拷贝构造函数（VS会调用；Linux不会，因为g++编译器做了优化，没有销毁函数中返回的那个对象）**
- 拷贝构造函数也可以重载
- 如果类中重载了拷贝构造函数却没有定义默认的拷贝构造函数，编译器也会提供默认的拷贝构造函数，**这一点和普通构造函数不一样**

### 105.5浅拷贝和深拷贝
- 深拷贝：
  - 先分配内存
  - 再拷贝数据：简单的类型可以直接赋值，复杂的可以用memcpy()函数
```C++
CGirl(const CGirl& gg)
{
  m_name = gg.m_name;
  m_age = gg.m_age;
  
  m_ptr = new int;  // 分配内存
  // *m_ptr = *gg.m_ptr;  // 拷贝数据1
  memcpy(m_ptr, gg.m_ptr, sizeof(int));  // 拷贝数据2
}  
```
### 106.初始化列表
```C++
CGirl():m_name("西施"), m_age(23)
{
  cout << "调用了CGirl()的构造函数\n";
}
```
- 注意：
  - 1.如果成员已经在初始化列表中，则不应该在构造函数中再次赋值 ,因为会将初始化列表的值覆盖掉
  - 3.初始化列表和赋值有本质的区别，如果成员是类，使用初始化列表调用的是成员类的拷贝构造函数，而赋值则是先创建成员类的对象（将调用成员类的普通构造函数），然后在赋值；如果不采用初始化列表，调用的是普通构造函数。如果采用初始化列表，调用的是拷贝构造函数。；如果没有初始化列表，对象的初始化和赋初始值是两步操作。如果采用了初始化列表，对象的初始化和赋值是一步操作。**所以采用初始化列表的效率更高**
  - 4.如果成员是类，初始化列表对性能略有提升
  - 5.如果成员是常量和引用，必须使用初始化列表，因为常量和引用只能在定义的时候初始化。
  - 6.如果成员是没有默认构造函数的类，则必须使用初始化列表。
  - 7.拷贝构造函数也可以有初始化列表，比较少用。
  - 8.类的成员变量可以不出现在初始化列表中，那么编译器就会采用默认的初始化方法。

### 107.const修饰成员
- 在类的成员函数后面加*const*关键字，表示在成员函数中保证不会修改调用对象的成员变量。
- 注意：在实际开发中，如果成员函数不会修改成员变量，就应该加const修饰，这是C++的编程规范，就像用const修饰函数的形参一样
- 注意：
  - 1.*mutable*可以突破*const*的限制，被*mutable*修饰的成员变量，将永远处于可变的状态，在*const*修饰的函数中，*mutable*成员也可以被修饰；也就是说，如果在声明时加了*mutable*关键字，那么即便成员函数加了*const*修饰，也能修改成员变量的值
  - 2.非*const***成员函数**可以调用*const*成员函数和非*const*成员函数
  - 3.*const*成员函数不能调用非*const*成员函数
- **提问：**
  - 1.为什么要保护类的成员变量不被修改？
  - 2.为什么用*const*保护了成员变量，还要再定义一个*mutable*关键字来突破*const*的封锁线？
  - 3.到底有没有必要使用*const*和*mutable*这两个关键字？
  - 4.常对象只能访问加了*const*修饰的成员函数；对构造函数和析构函数加*const*修饰是非法的
- **回答：**
  - 保护类的成员变量不在成员函数中被修改，是为了保证模型的正确性，通过用*const* 关键字来避免在函数中错误的修改了类对象的状态。并且在所用使用该成员函数的地方都可以更准确的预测到使用该成员函数带来的影响。而*mutable*则是为了突破*const*的封锁线，让累的一些次要的或者是辅助性的成员变量随时可以被修改。没有使用*const*和mutable当然也没有错，它们是只是给建模工具更多的设计约束性和灵活性，而且程序员可以把更多的逻辑检查问题交给编译器和建模工具去做，从而减轻程序员的负担。

### 108.this指针
- 如果类的成员函数中涉及多个对象，在这种情况下需要使用this指针。
- this指针存放了对象的地址，**它被作为隐藏参数传递给了成员函数**，指向调用成员函数的对象（调用者）
- this指针可以解决成员变量名与函数名相同的问题，当然用m_前缀或后缀的方法更好。
- \*this表示整个对象
```C++
int main()
{
  CGirl g1("西施",5),  g2("西瓜",3),  g3("冰冰",1),  g4("幂幂",5),  g5("金莲",2);
  const CGirl& g = g1.pk(g2).pk(g3).pk(g4).pk(g5);  // cout 也是类似的
  g.show();
}
```

### 109、静态成员
- 类的静态成员包括静态成员变量和静态成员函数。
- **如果把类的成员声明为静态的，就可以把它与类的对象独立开来（静态成员不属于对象）**
- 静态成员：
	- 使用*static*关键字进行修饰
	- 使用范围解析运算符*::*就可以访问，不需要创建对象。
	- **私有静态成员在类外无法访问**。不然类的静态成员与全局变量就没区别了
- 静态成员变量：
	- 可以实现多个对象间的数据共享，比全局变量更有安全性
	- 静态成员变量不会在创建对象的时候初始化，必须在程序的全局区用代码清晰地初始化（用范围解析运算符*::*）
	- const静态成员变量可以在定义类的时候初始化
- 静态成员函数：
	- 在静态成员函数中只能访问静态成员
	- 静态成员函数没有this指针（因为没对象）
	- 在非静态函数中可以访问静态成员（不用加范围解析运算符了）

### 110.简单对象模型
- C++中:
  - 有两种数据成员：nonstatic static;
  - 三种成员函数：nonstatic static virtual
- 静态成员变量属于类，在整个程序中只有一份，不计算在对象的大小范围之内
- 静态变量和全局变量和地址在一起，都在全局数据区
- 成员函数的地址和普通函数的地址是放在一起的
- 用空指针可以调用没有用到this指针的非静态成员函数。（如果成员函数中没有用到非静态成员变量，就可以用空指针去调用它）（其实这时候就是个C描述的普通函数了）
```C++
Girl girl = nullptr;
girl->showname();
```
- 在没有创建对象的情况下，访问非静态成员变量就是访问空指针。用空指针调用成员函数的情况很少见，为了保证程序的稳定性，在成员函数中可以增加判断this指针是否为空的代码
- 对象的地址是第一个非静态成员变量的地址，如果类中没有非静态成员变量，编译器会隐含增加一个1字节的占位成员
- [ ] 类的成员函数是分开存储的，不论对象是否存在，都占用存储空间，在内存中只有一个副本，也不计算在对象大小之内

## 使用类

### 111.友元
- 友元提供了另一访问类的私有成员的方案。
- 友元有三种：
  - 友元全局函数：在友元全局函数中，可以访问另一个类的所有成员
  - 友元类：在友元类所有成员函数中，可以访问另一个类的所有成员
  - 友元成员函数
#### （1） 友元全局函数 
- 声明友元的代码放在类中什么地方都可以，不受public和private关键字的约束，一般放在最上面
```C++
#include<iostream>
using namespace std;

class CGirl
{
    friend int main();
    friend void func();
    friend class CBoy;
public:
    string m_name;
    CGirl() { m_name = "西施"; m_xw = 87; }
    void showname() { cout << "姓名: " << m_name << endl; }
private:
    int m_xw;
    void showxw() { cout << "胸围：" << m_xw << endl; }
};

class CBoy
{
public:
    void func(const CGirl& g)
    {
        cout << "我女朋友的姓名是：" << g.m_name << endl;
        cout << "我女朋友的胸围是: " << g.m_xw << endl;
    }
};

void func()
{
    CGirl g;
    g.showxw();
}

int main()
{
    func();

    CGirl g;
    CBoy b;
    b.func(g);
}
```
- 这是非常规的操作，一般把普通的全局函数作为类的友元函数

#### （2）友元类
- 在友元类所有成员函数中，都可以访问另一个类的所有成员

- 友元类注意事项：
  - 友元关系不能被继承
  - 友元关系是单向的，不具备交换性、传递性 

#### (3) 友元成员函数
- 在友元成员函数中，可以访问另一个类的所有成员
- 如果要把男朋友类CBoy的某成员函数声明为超女类CGirl的友元，声明和定义的顺序如下：(友元成员函数和友元全局函数的原理是一样的，但是写代码的时候要注意声明和定义的顺序）
```C++
// 第一步：把超女类的声明前置
class CGirl;  // 前置声明 
// 第二步：把CBoy放在CGirl之前
// 第三步：把男朋友类的成员函数的函数体从类的定义中拿出来，放在定义超女类的后面
class CBoy {.....};
// 第四步：把男朋友类的成员函数声明为超女类的友元函数
class CGirl {.....};
```

```C++
#include<iostream>
using namespace std;

class CGirl;

class CBoy
{
public:
    void func1(const CGirl& g);

    void func2(const CGirl& g);
};

class CGirl
{
    friend void CBoy::func1(const CGirl& g);
    friend void CBoy::func2(const CGirl& g);

public:
    string m_name;
    CGirl() { m_name = "西施"; m_xw = 87; }
    void showname() { cout << "姓名: " << m_name << endl; }

private:
    int m_xw;
    void showxw() { cout << "胸围：" << m_xw << endl; }
};

void CBoy::func1(const CGirl& g)
{
    cout << "func1()我女朋友的胸围是: " << g.m_xw << endl;
}

void CBoy::func2(const CGirl& g)
{
    cout << "func2()我女朋友的胸围是: " << g.m_xw << endl;
}

int main()
{
    CGirl g;
    CBoy b;
    b.func1(g);
    b.func2(g);
}
```

### 121.自动类型装换
- **自动类型转换：** 某些类型的转换编译器可以隐式的进行，不需要程序员干预
- **强制类型转换：** 有些类型的转换需要程序员显示指定
- 若内置类型兼容，C++可以自动类型转换。大类型转小类型可能丢失精度（int -> long）

#### (1) 自动类型转换
自动类型转换的规则如下：
- 如果一个表达式中出现了不同类型操作数的混合运算，较低类型将自动想较高类型转换
- 当表达式中含有浮点数是，所有操作数都将转换为浮点数.
- 赋值运算的右值类型与左值类型不一致时，将右值类型提升/降低为左值类型。
- 赋值运算右值超出了左值类型的表示范围，把该右值截断后赋值给左值，所得结果可能毫无意义

#### (2) 强制类型转换
- 强制类型转换又称显示类型转换
- 语法：``` (目标类型)表达式。dynamic_cast<RadioButton*>(GetControl("btn_1")); ```
- 注意：
	- 如果用了强制类型转换，编译的警告信息将不再出现
	- 类型转换的优先级比较高，如果没把握就加上括号()
```C++
// C++不自动转换不兼容类型，下面语句非法
int* ptr = 8;
// 可以用强转。但是一般转换是要有意义的
int* ptr = (int*)8;
```

- 这节课学习把某种数据类型转换为类的类型

```C++
int main()
{
	// method 1
	CGirl g1(8);			// 常规的写法（有参构造）
	// method 2
	CGirl g1 = CGirl(8);	// 显式转换（有参构造）
	// method 3
	CGirl g1 = 8;			// 隐式转换（有参构造）
	// method 4
	CGirl g1;				// 创建对象（调用了默认无参构造函数）
	g1 = 8;					// 用CGirl(8)创建临时对象，再赋给g（再一次调用有参构造函数）
}
```

#### （3）强制类转换的特点：
- 1）一个类可以有多个转换函数
- 2）多个参数的构造函数，除第一个参数外，如果其他参数都有缺省值，也可以作为转换函数 
- 3）CGirl(int)的隐式转换的场景：
	- 将CGirl对象初始化为int值时。 ```C++ CGirl g1 = 8;  ```
	- 将int值赋给CGirl对象时。  ```C++ CGirl g1; g1 = 8; ```
	- 将int值传递给接受CGril参数的函数时。``` CGril function(CGril g) { return g}; function(8); ```
	- 返回值被声明为CGril的函数试图返回int值时。``` CGril function(int n) { return n}; function(8); ```
	- 在上述任意一种情况下，使用可转换为int类型的内置类型时（char）
- 4）如果自动类型转换有二义性，编译将报错
- 5）explicit关键字用于关闭这种自动特性，但仍允许显式转换
	-实际开发中如果强调的是构造，建议使用explicit，如果强调的是类型转换，则不适用explicit
```C++
explicit CGirl(int bh);
CGirl g = 8;  // wrong
CGirl g = CGirl(8);  // 显式转换，right
CGirl g = (CGirl)8;  // 显式转换，right
```

### 122.转换函数
- 构造函数只用于从某种类型转换到类类型的转换，如果要进行相反的转换，可以使用特殊的运算符函数-转换函数
- 语法：operator 数据类型()
- **注意：转换函数必须是类的成员函数；不能指定返回值类型；不能有参数**
```C++
class CGril
{
	int m_bh;  // 编号
	string m_name;
	double m_weight;
	
	// 默认构造函数
	CGirl() { m_bh = 8; m_name = "西施"; m_weight = 50.7; }
	
	explicit operator int() { return m_bh; } // 加了explicit就不能隐式转换了，这里编译器会选择double转换
	operator string() { return m_name; }
	operator double() { return m_weight; }
}

int main()
{
	CGirl g;
	int a = (int)g;  // 显式转换
	string b = g;  // 隐式转换
	double c = g;  // 隐式转换
	
	cout << "a: " << a << endl;
	cout << "b: " << b << endl;
	cout << "c: " << c << endl;
	
	short d = g;  // 没定义，产生二义性，因为int 和 double 都可以转换为short（我觉得应该用int，毕竟两个最相似）
	short d = (int)g;  // OK
}
```
- 这节课讲的意义不大，一般开发采用成员函数而不是转换函数
- 警告：应谨慎的使用隐式转换函数。通常，最好选择仅在被显式地调用时才会执行的成员函数。因为：**看视频！**

## [类继承](https://www.bilibili.com/video/BV1Qe4y1Y7jU)
### 继承的基本概念

