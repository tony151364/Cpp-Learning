## 类与对象

### 103.简单使用类
- 1.在类中使用枚举，作用域是整个类
- 2.在实际开发中，用结构体描述纯粹的数据，用类描述对象
- 3.在类的声明中定义的函数都将自动成为内联函数

### 104.构造函数和析构函数
- 1.在构造函数名后面加括号和参数不是调用构造函数，是创建匿名对象。
- 2.以下两行代码有本质区别：
```C++
CGirl girl = CGirl("西施", 20);  // 显式创建对象

// 一共创建了两个对象
CGirl girl;               // 创建对象
girl = CGirl("西施", 20);  // 创建匿名对象，然后给现有的对象赋值
```
- 3.用 new/delete 创建/销毁 对象时，也会调用 构造/析构 函数
- 4.不建议在 构造/析构 函数中写太多的代码，因为很多代码都是重复的，这时候可以把这些重复的代码放到一个成员函数（如：initData()）中，然后在构造函数中调用该成员函数。
- 5.除了初始化，不建议让构造函数做太多的工作，一般只作一些“只会成功不会失败”的工作。因为没有返回值，无法知道它的调用结果，所以复杂的工作交给它不太合适。
- 6.C++11 支持统一初始化列表
```C++
CGirl girl {"西施", 20}; 
CGirl girl= CGirl("西施", 20);
CGirl* girl =  new CGirl{"西施", 20};
```
- 7.如果类的成员也是类，创建对象时，先构造成员类；销毁对象时，先析构成员类

### 105.拷贝构造函数
- 在C++中，用一个已存在的对象创建新的对象，不会调用（普通）构造函数，而是调用拷贝构造函数。如果类中没有定义拷贝构造函数，编译器将提供一个拷贝构造函数，它的功能是把已存在对象的成员变量赋值给新对象的成员变量。
```C++
类名(const 类名& value)
CGirl(const CGirl& girl)
{
  m_name = 漂亮的+gg.m_name;
  m_age = gg.m_age - 1;
  cout << "..." << endl;
}
```
- 以值传递的方式调用函数时，如果实参为对象，调用拷贝构造函数(形参 = 实参）
- **函数以值的方式返回对象时，可能会调用拷贝构造函数（VS会调用；Linux不会，因为g++编译器做了优化，没有销毁函数中返回的那个对象）**
- 拷贝构造函数也可以重载
- 如果类中重载了拷贝构造函数却没有定义默认的拷贝构造函数，编译器也会提供默认的拷贝构造函数，**这一点和普通构造函数不一样**

### 105.5浅拷贝和深拷贝
- 深拷贝：
  - 先分配内存
  - 再拷贝数据：简单的类型可以直接赋值，复杂的可以用memcpy()函数
```C++
CGirl(const CGirl& gg)
{
  m_name = gg.m_name;
  m_age = gg.m_age;
  
  m_ptr = new int;  // 分配内存
  // *m_ptr = *gg.m_ptr;  // 拷贝数据1
  memcpy(m_ptr, gg.m_ptr, sizeof(int));  // 拷贝数据2
}  
```
### 106.初始化列表
```C++
CGirl():m_name("西施"), m_age(23)
{
  cout << "调用了CGirl()的构造函数\n";
}
```
- 注意：
  - 1.如果成员已经在初始化列表中，则不应该在构造函数中再次赋值 ,因为会将初始化列表的值覆盖掉
  - 3.初始化列表和赋值有本质的区别，如果成员是类，使用初始化列表调用的是成员类的拷贝构造函数，而赋值则是先创建成员类的对象（将调用成员类的普通构造函数），然后在赋值；如果不采用初始化列表，调用的是普通构造函数。如果采用初始化列表，调用的是拷贝构造函数。；如果没有初始化列表，对象的初始化和赋初始值是两步操作。如果采用了初始化列表，对象的初始化和赋值是一步操作。**所以采用初始化列表的效率更高**
  - 4.如果成员是类，初始化列表对性能略有提升
  - 5.如果成员是常量和引用，必须使用初始化列表，因为常量和引用只能在定义的时候初始化。
  - 6.如果成员是没有默认构造函数的类，则必须使用初始化列表。
  - 7.拷贝构造函数也可以有初始化列表，比较少用。
  - 8.类的成员变量可以不出现在初始化列表中，那么编译器就会采用默认的初始化方法。

### 107.const修饰成员
- 在类的成员函数后面加*const*关键字，表示在成员函数中保证不会修改调用对象的成员变量。
- 注意：在实际开发中，如果成员函数不会修改成员变量，就应该加const修饰，这是C++的编程规范，就像用const修饰函数的形参一样
- 注意：
  - 1.*mutable*可以突破*const*的限制，被*mutable*修饰的成员变量，将永远处于可变的状态，在*const*修饰的函数中，*mutable*成员也可以被修饰；也就是说，如果在声明时加了*mutable*关键字，那么即便成员函数加了*const*修饰，也能修改成员变量的值
  - 2.非*const***成员函数**可以调用*const*成员函数和非*const*成员函数
  - 3.*const*成员函数不能调用非*const*成员函数
- **提问：**
  - 1.为什么要保护类的成员变量不被修改？
  - 2.为什么用*const*保护了成员变量，还要再定义一个*mutable*关键字来突破*const*的封锁线？
  - 3.到底有没有必要使用*const*和*mutable*这两个关键字？
  - 4.常对象只能访问加了*const*修饰的成员函数；对构造函数和析构函数加*const*修饰是非法的
- **回答：**
  - 保护类的成员变量不在成员函数中被修改，是为了保证模型的正确性，通过用*const* 关键字来避免在函数中错误的修改了类对象的状态。并且在所用使用该成员函数的地方都可以更准确的预测到使用该成员函数带来的影响。而*mutable*则是为了突破*const*的封锁线，让累的一些次要的或者是辅助性的成员变量随时可以被修改。没有使用*const*和mutable当然也没有错，它们是只是给建模工具更多的设计约束性和灵活性，而且程序员可以把更多的逻辑检查问题交给编译器和建模工具去做，从而减轻程序员的负担。

### 108.this指针
- 如果类的成员函数中涉及多个对象，在这种情况下需要使用this指针。
- this指针存放了对象的地址，**它被作为隐藏参数传递给了成员函数**，指向调用成员函数的对象（调用者）
- this指针可以解决成员变量名与函数名相同的问题，当然用m_前缀或后缀的方法更好。
- \*this表示整个对象
```C++
int main()
{
  CGirl g1("西施",5),  g2("西瓜",3),  g3("冰冰",1),  g4("幂幂",5),  g5("金莲",2);
  const CGirl& g = g1.pk(g2).pk(g3).pk(g4).pk(g5);  // cout 也是类似的
  g.show();
}
```


