## 类与对象

### 103.简单使用类
- 1.在类中使用枚举，作用域是整个类
- 2.在实际开发中，用结构体描述纯粹的数据，用类描述对象
- 3.在类的声明中定义的函数都将自动成为内联函数

### 104.构造函数和析构函数
- 1.在构造函数名后面加括号和参数不是调用构造函数，是创建匿名对象。
- 2.以下两行代码有本质区别：
```C++
CGirl girl = CGirl("西施", 20);  // 显式创建对象

// 一共创建了两个对象
CGirl girl;               // 创建对象
girl = CGirl("西施", 20);  // 创建匿名对象，然后给现有的对象赋值
```
- 3.用 new/delete 创建/销毁 对象时，也会调用 构造/析构 函数
- 4.不建议在 构造/析构 函数中写太多的代码，因为很多代码都是重复的，这时候可以把这些重复的代码放到一个成员函数（如：initData()）中，然后在构造函数中调用该成员函数。
- 5.除了初始化，不建议让构造函数做太多的工作，一般只作一些“只会成功不会失败”的工作。因为没有返回值，无法知道它的调用结果，所以复杂的工作交给它不太合适。
- 6.C++11 支持统一初始化列表
```C++
CGirl girl {"西施", 20}; 
CGirl girl= CGirl("西施", 20);
CGirl* girl =  new CGirl{"西施", 20};
```
- 7.如果类的成员也是类，创建对象时，先构造成员类；销毁对象时，先析构成员类

### 105.拷贝构造函数
- 在C++中，用一个已存在的对象创建新的对象，不会调用（普通）构造函数，而是调用拷贝构造函数。如果类中没有定义拷贝构造函数，编译器将提供一个拷贝构造函数，它的功能是把已存在对象的成员变量赋值给新对象的成员变量。
```C++
类名(const 类名& value)
CGirl(const CGirl& girl)
{
  m_name = 漂亮的+gg.m_name;
  m_age = gg.m_age - 1;
  cout << "..." << endl;
}
```
- 以值传递的方式调用函数时，如果实参为对象，调用拷贝构造函数(形参 = 实参）
- **函数以值的方式返回对象时，可能会调用拷贝构造函数（VS会调用；Linux不会，因为g++编译器做了优化，没有销毁函数中返回的那个对象）**
- 拷贝构造函数也可以重载
- 如果类中重载了拷贝构造函数却没有定义默认的拷贝构造函数，编译器也会提供默认的拷贝构造函数，**这一点和普通构造函数不一样**

### 105.5浅拷贝和深拷贝
- 深拷贝：
  - 先分配内存
  - 再拷贝数据：简单的类型可以直接赋值，复杂的可以用memcpy()函数
```C++
CGirl(const CGirl& gg)
{
  m_name = gg.m_name;
  m_age = gg.m_age;
  
  m_ptr = new int;  // 分配内存
  // *m_ptr = *gg.m_ptr;  // 拷贝数据1
  memcpy(m_ptr, gg.m_ptr, sizeof(int));  // 拷贝数据2
}  
```
### 106.初始化列表
```C++
CGirl():m_name("西施"), m_age(23)
{
  cout << "调用了CGirl()的构造函数\n";
}
```
- 注意：
  - 1.如果成员已经在初始化列表中，则不应该在构造函数中再次赋值 ,因为会将初始化列表的值覆盖掉
  - 3.初始化列表和赋值有本质的区别，如果成员是类，使用初始化列表调用的是成员类的拷贝构造函数，而赋值则是先创建成员类的对象（将调用成员类的普通构造函数），然后在赋值；如果不采用初始化列表，调用的是普通构造函数。如果采用初始化列表，调用的是拷贝构造函数。；如果没有初始化列表，对象的初始化和赋初始值是两步操作。如果采用了初始化列表，对象的初始化和赋值是一步操作。**所以采用初始化列表的效率更高**
  - 4.如果成员是类，初始化列表对性能略有提升
  - 5.如果成员是常量和引用，必须使用初始化列表，因为常量和引用只能在定义的时候初始化。
  - 6.如果成员是没有默认构造函数的类，则必须使用初始化列表。
  - 7.拷贝构造函数也可以有初始化列表，比较少用。
  - 8.类的成员变量可以不出现在初始化列表中，那么编译器就会采用默认的初始化方法。

### 107.const修饰成员
- 在类的成员函数后面加*const*关键字，表示在成员函数中保证不会修改调用对象的成员变量。
- 注意：在实际开发中，如果成员函数不会修改成员变量，就应该加const修饰，这是C++的编程规范，就像用const修饰函数的形参一样
- 注意：
  - 1.*mutable*可以突破*const*的限制，被*mutable*修饰的成员变量，将永远处于可变的状态，在*const*修饰的函数中，*mutable*成员也可以被修饰；也就是说，如果在声明时加了*mutable*关键字，那么即便成员函数加了*const*修饰，也能修改成员变量的值
  - 2.非*const***成员函数**可以调用*const*成员函数和非*const*成员函数
  - 3.*const*成员函数不能调用非*const*成员函数
- **提问：**
  - 1.为什么要保护类的成员变量不被修改？
  - 2.为什么用*const*保护了成员变量，还要再定义一个*mutable*关键字来突破*const*的封锁线？
  - 3.到底有没有必要使用*const*和*mutable*这两个关键字？
  - 4.常对象只能访问加了*const*修饰的成员函数；对构造函数和析构函数加*const*修饰是非法的
- **回答：**
  - 保护类的成员变量不在成员函数中被修改，是为了保证模型的正确性，通过用*const* 关键字来避免在函数中错误的修改了类对象的状态。并且在所用使用该成员函数的地方都可以更准确的预测到使用该成员函数带来的影响。而*mutable*则是为了突破*const*的封锁线，让累的一些次要的或者是辅助性的成员变量随时可以被修改。没有使用*const*和mutable当然也没有错，它们是只是给建模工具更多的设计约束性和灵活性，而且程序员可以把更多的逻辑检查问题交给编译器和建模工具去做，从而减轻程序员的负担。

### 108.this指针
- 如果类的成员函数中涉及多个对象，在这种情况下需要使用this指针。
- this指针存放了对象的地址，**它被作为隐藏参数传递给了成员函数**，指向调用成员函数的对象（调用者）
- this指针可以解决成员变量名与函数名相同的问题，当然用m_前缀或后缀的方法更好。
- \*this表示整个对象
```C++
int main()
{
  CGirl g1("西施",5),  g2("西瓜",3),  g3("冰冰",1),  g4("幂幂",5),  g5("金莲",2);
  const CGirl& g = g1.pk(g2).pk(g3).pk(g4).pk(g5);  // cout 也是类似的
  g.show();
}
```

### 109、静态成员
- 类的静态成员包括静态成员变量和静态成员函数。
- **如果把类的成员声明为静态的，就可以把它与类的对象独立开来（静态成员不属于对象）**
- 静态成员：
	- 使用*static*关键字进行修饰
	- 使用范围解析运算符*::*就可以访问，不需要创建对象。
	- **私有静态成员在类外无法访问**。不然类的静态成员与全局变量就没区别了
- 静态成员变量：
	- 可以实现多个对象间的数据共享，比全局变量更有安全性
	- 静态成员变量不会在创建对象的时候初始化，必须在程序的全局区用代码清晰地初始化（用范围解析运算符*::*）
	- const静态成员变量可以在定义类的时候初始化
- 静态成员函数：
	- 在静态成员函数中只能访问静态成员
	- 静态成员函数没有this指针（因为没对象）
	- 在非静态函数中可以访问静态成员（不用加范围解析运算符了）

### 110.简单对象模型
- C++中:
  - 有两种数据成员：nonstatic static;
  - 三种成员函数：nonstatic static virtual
- 静态成员变量属于类，在整个程序中只有一份，不计算在对象的大小范围之内
- 静态变量和全局变量和地址在一起，都在全局数据区
- 成员函数的地址和普通函数的地址是放在一起的
- 用空指针可以调用没有用到this指针的非静态成员函数。（如果成员函数中没有用到非静态成员变量，就可以用空指针去调用它）（其实这时候就是个C描述的普通函数了）
```C++
Girl girl = nullptr;
girl->showname();
```
- 在没有创建对象的情况下，访问非静态成员变量就是访问空指针。用空指针调用成员函数的情况很少见，为了保证程序的稳定性，在成员函数中可以增加判断this指针是否为空的代码
- 对象的地址是第一个非静态成员变量的地址，如果类中没有非静态成员变量，编译器会隐含增加一个1字节的占位成员
- [ ] 类的成员函数是分开存储的，不论对象是否存在，都占用存储空间，在内存中只有一个副本，也不计算在对象大小之内

## 使用类

### 111.友元
- 友元提供了另一访问类的私有成员的方案。
- 友元有三种：
  - 友元全局函数
  - 友元类
  - 友元成员函数
#### （1） 友元全局函数 
- 声明友元的代码放在类中什么地方都可以，不受public和private关键字的约束，一般放在最上面
```C++
class CGirl
{
  friend int main();
  friend void func();
  friend class CBoy;
public:
  string m_name;
  CGril() { m_name = "西施"; m_xw = 87;}
  void showname() { cout << "姓名: " << m_name << endl; }
private:
  int m_xw;
  void showxw() { cout << "胸围：" << m_xw << endl; }
};

class CBoy
{
  void func(const CGirl& g)
  {
    cout << "我女朋友的姓名是：" << g.m_name << endl;
    cout << "我女朋友的胸围是: " << g.m_xw << endl;
  }
}
int func()
{
  CGirl g;
  g.showxw();
}
int main()
{
  int func();
  
  CGirl g;
  CBoy b;
  b.func(g);
}
```
- 这是非常规的操作，一般把普通的全局函数作为类的友元函数

#### （2）友元类
- 在友元类所有成员函数中，都可以访问另一个类的所有成员

- 友元类注意事项：
  - 友元关系不能被继承
  - 友元关系是单向的，不具备交换性、传递性 

#### (3) 友元成员函数
- 在友元成员函数中，可以访问另一个类的所有成员
- 如果要把男朋友类CBoy的某成员函数声明为超女类CGirl的友元，声明和定义的顺序如下：(友元成员函数和友元全局函数的原理是一样的，但是写代码的时候要注意声明和定义的顺序）
```C++
class CGirl;  // 前置声明 
class CBoy {.....};
class CGirl {.....};
```

### 112.运算符重载


### 113.自动类型装换









