## 类与对象

### 简单使用类
- 1.在类中使用枚举，作用域是整个类
- 2.在实际开发中，用结构体描述纯粹的数据，用类描述对象
- 3.在类的声明中定义的函数都将自动成为内联函数

### 构造函数和析构函数
- 1.在构造函数名后面加括号和参数不是调用构造函数，是创建匿名对象。
- 2.以下两行代码有本质区别：
```C++
CGirl girl = CGirl("西施", 20);  // 显式创建对象

// 一共创建了两个对象
CGirl girl;               // 创建对象
girl = CGirl("西施", 20);  // 创建匿名对象，然后给现有的对象赋值
```
- 3.用 new/delete 创建/销毁 对象时，也会调用 构造/析构 函数
- 4.不建议在 构造/析构 函数中写太多的代码，因为很多代码都是重复的，这时候可以把这些重复的代码放到一个成员函数（如：initData()）中，然后在构造函数中调用该成员函数。
- 5.除了初始化，不建议让构造函数做太多的工作，一般只作一些“只会成功不会失败”的工作。因为没有返回值，无法知道它的调用结果，所以复杂的工作交给它不太合适。
- 6.C++11 支持统一初始化列表
```C++
CGirl girl {"西施", 20}; 
CGirl girl= CGirl("西施", 20);
CGirl* girl =  new CGirl{"西施", 20};
```
- 7.如果类的成员也是类，创建对象时，先构造成员类；销毁对象时，先析构成员类

### 拷贝构造函数
- 在C++中，用一个已存在的对象创建新的对象，不会调用（普通）构造函数，而是调用拷贝构造函数。如果类中没有定义拷贝构造函数，编译器将提供一个拷贝构造函数，它的功能是把已存在对象的成员变量赋值给新对象的成员变量。
```C++
类名(const 类名& value)
CGirl(const CGirl& girl)
{
  m_name = 漂亮的+gg.m_name;
  m_age = gg.m_age - 1;
  cout << "..." << endl;
}
```
- 以值传递的方式调用函数时，如果实参为对象，调用拷贝构造函数(形参 = 实参）
- **函数以值的方式返回对象时，可能会调用拷贝构造函数（VS会调用；Linux不会，因为g++编译器做了优化，没有销毁函数中返回的那个对象）**
- 拷贝构造函数也可以重载
- 如果类中重载了拷贝构造函数却没有定义默认的拷贝构造函数，编译器也会提供默认的拷贝构造函数，**这一点和普通构造函数不一样**










