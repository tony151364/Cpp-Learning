
### 未解决
- [指针数组](https://www.nowcoder.com/test/question/done?tid=56767737&qid=3733#referAnchor)
- [数组指针](https://www.nowcoder.com/test/question/done?tid=56768251&qid=4971#summary)
- [const 与指针](https://www.nowcoder.com/test/question/done?tid=56768251&qid=3181#summary)
- [三目运算符](https://www.nowcoder.com/test/question/done?tid=56768251&qid=111823#summary)
- [三目运算符2](https://www.nowcoder.com/test/question/done?tid=56768251&qid=78438#summary)
- [C语言文件](https://www.nowcoder.com/test/question/done?tid=56767737&qid=326200#summary)
- [C++中结构体](https://www.nowcoder.com/test/question/done?tid=56768251&qid=78438#summary)
- [移位操作](https://www.nowcoder.com/test/question/done?tid=56768251&qid=36433#summary)
- [第27题 复杂声明](https://www.cnblogs.com/yjd_hycf_space/p/7495640.html)

### 参考内容
- [牛客网]([url](https://www.nowcoder.com/exam/intelligent))
- [经典C++笔试面试题目与参考答案100例](https://www.jb51.net/it/692577.html)
- [C++ 面试题目(整理自牛客网)](https://www.jb51.net/it/713160.html)
- [GitHub面试C++](https://github.com/huihut/interview#cc)
- [cnblog](https://www.cnblogs.com/yjd_hycf_space/p/7495640.html)
- [iamshuidi](https://www.iamshuaidi.com/2337.html)

- [ ] C++客户端主要干什么？
- [ ] 看视频：虚函数、析构函数

## 自我介绍
- 您好我是计算机专业的应届生，喜欢钻研技术，有较强的自学能力。本科期间做过“大球吃小球”、“井字棋”两个小游戏，做过一个《人脸智能识别系统》对编程有点一定的热爱，同时自己也喜欢玩游戏，希望能入职到游戏行业。

## 第一部分：C++与C语言差异

### 1.如何判断一段程序是由C编译程序还是由C++编程程序编译的？
```C++
#ifdef __cplusplus
        cout<<"c++";
#else
        printf("c");
#endif
```
### 2.C和C++有什么不同？
- 从机制上讲：C语言是面向过程的；C++是面向对象的，提供了类。编程时侧重类的设计和实现
- C++是C的超集，也就是C++包含了C，C语言的程序可以在C++中运行，反之不可以。
- 从使用方向：C适合要求代码体积小的、效率高的场合，如嵌入式；C++适合更上层，复杂的软件。对于效率要求高的软件，如操作系统。一般都是用C或C++编写的。
- C++引入new/delete运算符，取代了C中的malloc/free库函数
- C++引入引用、类、函数函数重载等特性，这些是C中所没有的

### 3.某文件中定义的静态全局变量（或静态外部变量）其作用域是()？
- 本文件
- 静态全局变量限制了其作用域，即只在定义该变量的源文件内有效，在同一源程序的其他源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为源文件内的函数公用，因此可以避免在其它源文件中引起错误

### 4.C++函数中值的传递方式有哪几种？
- 值传递、指针传递和引用传递

### 5.对于一个频繁使用的短小函数，在C语言中应用什么实现，在C++中应用什么实现？
- C用宏定义，C++用inline

### 6.引用和指针的区别（重点）
- ① 引用必须被初始化，指针不必。所以说，不存在指向空值的引用，但存在指向空值的指针
- ② 引用相当于加了const的指针，即初始化后不能给改变

### 7.const 与 #define的比较，const有什么优点？
- const作用：定义常量、修饰函数参数、修饰函数返回值三个作用。被const修饰的东西都受到强制保护，可以预防意外的变动，能提高程序的健壮性。
- ① const常量有数据类型、而宏常量没有数据类型。编译器可以对前者进行类型安全检查。后者只是文本替换，而且替换容易出现错误。
- ② 有些集成化的调试工具可以对const常量进行调试，但是不能对宏常量进行调试。

### 8.有了malloc/free 为什么还要new/delete？
- delete会调用对象的折构函数，和new对应free只能释放内存，new调用构造函数。
- malloc与free是C/C++的标准库函数，new/delete，像sizeof一样，是C++的运算符。它们都可用于申请动态内存的释放内存。
- 对于非内部数据类型的对象而言，光用malloc/free是无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行折构函数
- 由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和折构函数的任务强加于malloc/free。
- 因此C++语言需要一个能完成动态内存分配和初始化工作的运算符new，以及一个能够清理和释放内存工作的运算符delete。

### 9.如果在申请动态内存时找不到足够大的内存块，malloc和new将返回NULL指针，宣告内存申请失败。你是怎么处理内存耗尽的？
- ① 判断指针是否为NULL，如果是则马上用return语言终止本函数
- ② 判断指针是否为NULL，如果是则用exit(1)终止整个程序的指针。（exie(1) or exit(0)??）
- ③ 为new和malloc设置异常处理函数。例如Visual C++可以用_set_new_hander函数为new设置用户自己定义的异常处理函数。也可以让malloc与new使用相同的异常处理函数

### 10.宏定义、用法等等


## 第二部分：类型、关键字和函数

### 1.C++是不是类型安全的？
- 不是。两个不同类型的指针之间可以强制转换(用reinterpret cast)
- 类型安全，很大程度上，可以等价于内存安全。类型安全的代码，不会试图访问自己没被授权的内存区域。

### [2.const符号常量不同位置的作用？](https://blog.csdn.net/baidu_35679960/article/details/83504018)
- 1、 第一个const：函数的返回值是const。
        - 此处返回const值,意思指返回的原函数里的变量的初值不能被修改,但是函数按值返回的这个变量被制成副本,能不能被修改就没有了意义,它可以被赋给任何的const或非const类型变量,完全不需要加上这个const关键字.但这只对于内部类型而言(因为内部类型返回的肯定是一个值,而不会返回一个变量,不会作为左值使用),对于用户自定义类型,返回值是常量是非常重要的.
- 2、第二个const：函数参数是const。传递过来的参数var在函数内不可以改变，一般我们的只读参数需要使用const来加以保护；
- 3、第三个const：该函数是const。编译器会对这个函数进行检查,在这个函数中的任何试图改变成员变量和调用非const成员函数的操作都被视为非法。

- delete只会调用一次折构函数，而delete[]会调用每一个成员的折构函数。在More Effective C++中有更为详细的解释：“当delete操作符用于数组是，它为每个数组元素调用折构函数，然后调用operator delete”来释放内存。"delete"与new配套，delete[] 与new[]配套
```C++
MemTest *mTest1 = new MemTest[10];
MemTest *mTest1 = new MemTest;
Int *pInt1 = new int [10];
Int *pInt2 = new int;

delete [] pInt1;  //  -1-
delete [] pInt2;  // -2-
delete [] mTest1;  // -3-
delete [] mTest2;  // -4-
```
- 在-4-出报错。
- 这就说明：对于简单数据类型，delete和delete[]功能是相同的。对于自定义的复杂数据类型，delete和delete[]不能互用。delete[] 删除一个数组，delete删除一个指针。
- 简单来说，用new分配的内存用delete删除；用new[]分配的内存用delet[]删除。delete[]会调用数组元素的折构函数。内部数据类型没有折构函数，所以问题不大。如果你再用delete时没有括号，delete就会认为指向的是单个对象。否则，就认为指向的是数组。

### 4.什么是“引用”？申明和使用“引用”要注意哪些问题？
- 引用就是某个目标变量的“别名”(alias)，对应用的操作与对变量直接操作效果完全相同。申明一个引用的时候，切记要对其进行初始化。引用声明完毕后，相当于目标变量名有两个名称，即该目标原名称和引用名，不能再把该引用名作为其他变量名的别名。声明一个引用，不是新定义了一个变量，它只表示该引用名是目标变量名的一个别名，它本身不是一种数据类型，因此引用本身不占存储单元，系统也不给引用分配存储单元。不能建立数组的引用。

### 5.将“引用”作为函数参数有哪些特点？
- （1）传递引用给函数与传递指针的效果是一样的。这时，被调函数的形参就成为原来主调函数中的实参变量或对象的一个别名来使用，所以在被调函数中对形参变量的操作就是对其相应的目标对象（在主调函数中）的操作。
- （2）使用引用传递函数的参数，在内存中并没有产生实参的副本，它是直接对实参操作；而使用一般变量传递函数的参数，当发生函数调用时，需要给形参分配存储单元，形参变量是实参变量的副本；如果传递的是对象，还将调用拷贝构造函数。因此，当参数传递的数据较大时，用引用比用一般变量传递参数的效率和所占空间都好。
-（3）使用指针作为函数的参数虽然也能达到与使用引用的效果，但是，在被调函数中同样要给形参分配存储单元，且需要重复使用"\*指针变量名"的形式进行运算，这很容易产生错误且程序的阅读性较差；另一方面，在主调函数的调用点处，必须用变量的地址作为实参。而引用更容易使用，更清晰。

### 6.在什么时候需要使用“常引用”？
- 如果既要利用引用提高程序的效率，又要保护传递给函数的数据不在函数中被改变，就应使用常引用。
- 常引用声明方式:``` const 类型标识符 &引用名 = 目标变量名; ```
```C++
// 例子1
int a;
const int &ra = a;
ra = 1;  // 错误
a = 1;  // 正确

// 例子2
string foo();
void bar(string &s);
// 那么下面的表达式将是非法的
bar(foo());
bar("hello world");
/*
原因在于:
在于foo( )和"hello world"串都会产生一个临时对象，而在C++中，这些临时对象都是const类型的。因此上面的表达式就是试图将一个const类型的对象转换为非const类型，这是非法的。引用型参数应该在能被定义为const的情况下，尽量定义为const 。
*/
```
### 7.将“引用”作为函数返回值的格式、好处和需要遵守的规则
- 格式：``` 类型标识符 &函数名 （形参列表及类型说明） {  // 函数体} ```
- 好处：在内存中不产生被返回值的副本；（注意：正是因为这点原因，所以返回一个局部变量的引用是不可取的。因为随着该局部变量生存期的结束，相应的引用也会失效，产生runtime error！）
- 其他略


### 8.结构和联合有什么区别？
- （1）结构和联合都是由多个不同的数据类型成员组成，但在任何同一时刻，联合中只存放了一个被选择的成员（所有成员公用一块地址空间），而结构的所有成员都存在（不同成员的存放地址不同）
- （2）对于联合的不同成员赋值，将会对其他成员重写，原来成员的值就不存在了，而对于结构的不同成员赋值互不影响

### 9.有哪几种情况只能用initialization list(初始化表，或叫列表初始化）而不能用assignment（赋值运算符）
- 当类中含有const、reference成员变量还有基类的构造函数都需要初始化表

### 10.main函数执行以前，还好执行什么代码
- 全局对象的构造函数会在main函数之前执行

### 11.分别写出BOOL，int，float，指针类型的变量a与“零”的比较语句
```C++
BOOL: if (!a) or if (a)
int: if (a == 0)
float: const EXPRESSION EXP = 0.0000001
        if (a < EXP && a > - EXP)
pointer: if (a != NULL) or if (a == NULL)
```

### 12.简述数组与指针的区别
- 内存中的位置：数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。指针可以随时指向任意类型的内存块。
- （1）数组名是指针常量，指向的位置不能变
- （2）sizeof：用运算符sizeof可以计算出数组的容量（字节数）。sizeof（p），p为指针得到的是一个指针变量的字节数，而不是p所指的内存容量。C++/C语言没有办法知道指针所指的内存容量，除非在申请内存时记住它。注意当数组作为函数的参数进行传递是，该数组自动退化为同类型指针。

### 13. ``` int(*s[10])(int) ```表示的是什么？
- 它是函数指针数组，每个指针指向一个int func(int param)的函数

### 14. ``` int id[sizeof(unsigned long)] ``` 这对吗？
- 正确，这个sizeof是编译时运算符，编译时就确定了，可以看成和机器有关的常量

### 15.全局变量和局部变量有什么区别？是怎么实现的？操作系统和编译器是怎么知道的
- 声明周期不同：全局变量随主程序创建而创建，随主程序销毁而销毁；局部变量在局部函数内部，甚至局部循环体等内部存在，退出就不存在；
- 使用方式不同：通过声明后全局变量程序的各个部分都可以用到；局部变量只能在局部使用；分配在栈区。
- 操作系统和编译器通过内存分配的位置来知道，全局变量分配在全局数据段并且在程序开始运行的时候被加载。局部变量则分配在堆栈里面。
### 16.static关键字有什么用？
- 修饰局部变量时，使得该变量在静态存储区分配内存；只能在首次函数调用中进行首次初始化，之后的函数调用不再进行初始化；其生命周期与程序相同，但其作用域为局部作用域，并不能一直被访问。
- 修饰全局变量是，使得该变量在静态静态存储区分配内存；在声明该变量的整个文件中都是可见的，而在文件外是不可见的
- 修饰函数时，在声明该函数的整个文件中都是可见的，而在文件外是不可见的，从而可以在多人协作时避免同名函数的冲突。
- 修饰成员变量是，所有的对象都只维持一份拷贝，可以实现不同对象间的数据共享；不需要实例化对象即可访问；不能在类内部初始化，一般在类外部初始化，并且初始化时不加```static```
- 修饰成员函数时，该函数不接受this指针，只能访问类的静态成员；不需要实例化对象即可访问。
- **C语言的关键字static和C++的关键字static有什么区别？**
        - 在C中static用来修饰局部静态变量和外部静态变量、函数。而C++中除了上述功能外、还用来定义类的成员变量和函数。即静态成员和静态成员函数
        -  编程时 static 的记忆性，和全局性的特点可以让在不同时期调用的函数进行通信，传递信息，而 C++的静态成员则可以在多个对象实例间进行通信，传递信息

### 17.右值引用有什么作用？
- 右值引用的主要目的是为了实现转义语义的完美转发，消除两个对象交互时不必要的对象拷贝，也能够更加简洁的定义泛型函数
- 什么是泛型函数？
        - 一般化并可重复使用的算法，其效率与针对某特定数据类型而设计的算法相同。<template>、函数重载 
- 什么是左值引用？ 
        - 可以在左边被复制

### 18.简述#ifdef、#else、#endif和#ifdef的作用
- 利用#ifdef、#endif将某程序功能模块包括进去，以向特定用户提供该功能。在不需要是用户可轻易将其屏蔽
```C++
#ifdef MATH
#include "math.c"
#endif
```
- 在子程序前加上标记，以便于追踪和调试
```C++
#ifdef DEBUG
printf("Indebugging.......!");
#endif
```
- **注意**：虽然不同条件编译命令而直接用if语句也能达到要求，但那样做目标程序（所有语句都编译），运行时间长（因为程序运行时间对if语句进行测试）。而采用条件编译，可以减少被编译的语句，从而减少目标程序的长度，减少运行时间。      
   
### 18.说一说extern “C”
- extern"C"的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern “C”后，会指示编译器这部分代码按C语言（而不是C++）的方式进行编译。由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名。       
- 这个功能十分有用处，因为在C++出现以前，很多代码都是C语言写的，而且很底层的库也是C语言写的，为了更好的支持原来的C代码和已经写好的C语言库，需要在C++中尽可能的支持C，而extern “C”就是其中的一个策略。

- C++调用C语言代码
- 在C++头文件中使用
- 在多人协同开发是，可能有人擅长C语言，而有人擅长C++，这样的情况下会用到。
   
- 如果全局变量不在文件的开头定义，有效的作用范围将只限于其定义处到文件结束。如果在定义点之前的函数想引用该全局变量，则应该在引用之前用关键字 extern 对该变量作“外部变量声明”，表示该变量是一个已经定义的外部变量。有了此声明，就可以从“声明”处起，合法地使用该外部变量。
    
### 19.静态链接和动态链接的区别
- 静态链接是在编译链接时直接将需要的执行代码拷贝到调用处；
优点在于程序在发布时不需要依赖库，可以独立执行，缺点在于程序的体积会相对较大，而且如果静态库更新之后，所有可执行文件需要重新链接
        
- 动态链接是在编译时不直接拷贝执行代码，而是通过记录一系列符号和参数，在程序运行或加载时将这些信息传递给操作系统，操作系统负责将需要的动态库加载到内存中，然后程序在运行到指定代码时，在共享执行内存中寻找已经加载的动态库可执行代码，实现运行时链接；
- 优点在于多个程序可以共享同一个动态库，节省资源；缺点在于由于运行时加载，可能影响程序的前期执行性能。
        
### 20.对于一个频繁使用的短小函数，应该用什么来实现，有什么缺点？（内联函数）
应该使用inline内联函数，即编译器将inline内联函数内的代码替换到函数被调用的地方。  
优点：
- 在内联函数被调用的地方进行代码展开，省去函数调用的时间，从而提高程序运行效率；
- 相比于宏函数，内联函数在代码展开时，编译器会进行语法安全检查或数据类型转换，使用更加安全；
缺点：
- 代码膨胀，产生更多的开销；
- 如果内联函数内代码块的执行时间比调用时间长得多，那么效率的提升并没有那么大；
- 如果修改内联函数，那么所有调用该函数的代码文件都需要重新编译；
- 内联声明只是建议，是否内联由编译器决定，所以实际并不可控。
        
        
## 第三部分：C++面向对象的特性
- [ ] 析构函数
- [ ] 虚函数 


### 1.C++有哪些性质（面向对象特点）
- 封装，继承和多态
### [2.析构函数？](http://c.biancheng.net/view/152.html)
- 析构函数是成员函数的一种，它的名字与类名相同，但前面要加~，没有参数和返回值
- 一个类有且仅有一个析构函数。如果定义类时没写折构函数，则编译器默认生成折构函数。如果定义了折构函数，则编译器不生成默认析构函数。
- 析构函数在对象消亡时即自动被调用。可以定义析构函数在对象消亡前做善后工作。例如，对象如果在生产期间用new运算符动态分配了内存，则在各处写delete语句以确保程序的每条语句执行路径都能释放这片内存是比较麻烦的事情。有了析构函数，只要在析构函数中调用delete语句，就能确保对象运行中用new运算符分配的空间在对象消亡时被释放。
- 例如下面代码：
```C++
class String{
private:
    char* p;
public:
    String(int n);
    ~String();
};
String::~String(){
    delete[] p;
}
String::String(int n){
    p = new char[n];
}
```
- String类的成员变量p指向动态分配的一片存储空间，用于存放字符串。动态内存分配在折构函数中进行，而空间的释放在折构函数~String()中进行。这样，在其他地方就不用考虑释放空间的事情了。
只要对象消亡，就会引发折构函数的调用。
- 略

### 3.子类析构时要调用父类的析构函数吗？
- 析构函数调用的次序是先派生类的析构，然后是基类的析构。也就说，在基类的析构调用的时候，派生类的信息已经全部摧毁了。
- 定义个对象时先调用基类的构造函数、然后调用派生类的构造函数；
- 析构的时候恰好相反：先调用派生类的析构函数，然后调用基类的析构函数。

### 4.多态、虚函数、纯虚函数
- 多态：对于不同对象接收相同消息是产生不同动作。
- C++的多态性具体体现在运行和编译两个方面：
        - 在程序运行时的多态通过继承和虚函数来体现；
        - 在程序编译时多态性体现自函数和运算符的重载上；
- 虚函数：在基类中冠以关键字virtual的成员函数。它提供了一种接口界面。允许在派生类中对基类的虚函数重新定义。（重写）
- 纯虚函数的作用： 在基类中为其派生类保留一个函数的名字，以便派生类根据需要对它进行定义。作为接口而存在纯虚函数不具备函数的功能，一般不能直接被调用。
- 从基类继承来的纯虚函数，在派生类中仍是虚函数。如果一个类至少有一个纯虚函数，那么这个类被称为抽象类(abstract class)。
- 抽象类不仅包括纯虚函数，也可包括虚函数。抽象类必须用作派生类其他类的基类，而不能用于直接创建对象实例。但仍可使用抽闲累的指针支持运行时多态性。

### 5.重载（overload）和重写（overried，有的书也叫做“覆盖”）的区别？
- 从定义上说：
        - 重载：是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或者参数类型不同，或者两者都不太）
        - 是指子类重新定义父类虚函数的方法
- 从实现原理上来说：
        - 重载：编译器根据函数不同的参数表，对同名函数的名称做修饰，然后这些同名函数就成了不同的函数
        - 重写：和多态真正相关。当子类重新定义了父类的虚函数后，父类指针根据给它不同的子类指针，动态调用属于子类的该函数，这样的函数在编译期间是无法确定的（调用的子类的虚函数的地址无法给出）。因此，这样的函数地址是在运行期绑定的（晚绑定）

### 基类的析构函数不是虚函数，会带来什么问题
- 派生类的析构函数用不上，会造成资源的泄露。

## 第四 部分 内存
### 1.内存是如何分区的，存储什么内容？
- 程序代码区
- 常量区存放常量。程序结束时由OS回收。
- 全局区（静态区）存放全局变量和静态变量。初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。 程序结束时由OS回收。内存在编译的时候就已经分配好，这块内存在程序整个运行期间都存在。例如全局变量、static变量
- 堆区存放的变量（用new，malloc，calloc，realloc等分配内存函数得到的变量）由程序员分配释放。动态内存分配，生存周期由程序员决定。
- 栈区存放的变量（局部变量、函数参数等）由编译器自动分配释放。栈内存分配运算内置于处理器的指令集


## Linux命令
- ls:查看当前目录下文件
- pwd：当前路径
- cp 复制
- mv 移动
- rm 删除
- mkdir 创建文件夹
- cat可以查看真个文件
