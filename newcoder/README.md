
### 未解决
- [指针数组](https://www.nowcoder.com/test/question/done?tid=56767737&qid=3733#referAnchor)
- [数组指针](https://www.nowcoder.com/test/question/done?tid=56768251&qid=4971#summary)
- [const 与指针](https://www.nowcoder.com/test/question/done?tid=56768251&qid=3181#summary)
- [三目运算符](https://www.nowcoder.com/test/question/done?tid=56768251&qid=111823#summary)
- [三目运算符2](https://www.nowcoder.com/test/question/done?tid=56768251&qid=78438#summary)
- [C语言文件](https://www.nowcoder.com/test/question/done?tid=56767737&qid=326200#summary)
- [C++中结构体](https://www.nowcoder.com/test/question/done?tid=56768251&qid=78438#summary)
- [移位操作](https://www.nowcoder.com/test/question/done?tid=56768251&qid=36433#summary)

### 参考内容
- [牛客网]([url](https://www.nowcoder.com/exam/intelligent))
- [经典C++笔试面试题目与参考答案100例](https://www.jb51.net/it/692577.html)
- [C++ 面试题目(整理自牛客网)](https://www.jb51.net/it/713160.html)
- [GitHub面试C++](https://github.com/huihut/interview#cc)
- [cnblog](https://www.cnblogs.com/yjd_hycf_space/p/7495640.html)
- [iamshuidi](https://www.iamshuaidi.com/2337.html)

- [ ] C++客户端主要干什么？
## 第一部分：C++与C语言差异
### 1.如何判断一段程序是由C编译程序还是由C++编程程序编译的？
```C++
#ifdef __cplusplus
        cout<<"c++";
#else
        printf("c");
#endif
```
### 2.C和C++有什么不同？
- 从机制上讲：C语言是面向过程的；C++是面向对象的，提供了类。编程时侧重类的设计和实现
- C++是C的超集，也就是C++包含了C，C语言的程序可以在C++中运行，反之不可以。
- 从使用方向：C适合要求代码体积小的、效率高的场合，如嵌入式；C++适合更上层，复杂的软件。对于效率要求高的软件，如操作系统。一般都是用C或C++编写的。
### 3.某文件中定义的静态全局变量（或静态外部变量）其作用域是()？
- 本文件
- 静态全局变量限制了其作用域，即只在定义该变量的源文件内有效，在同一源程序的其他源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为源文件内的函数公用，因此可以避免在其它源文件中引起错误
### 4.C++函数中值的传递方式有哪几种？
- 值传递、指针传递和引用传递
### 5.对于一个频繁使用的短小函数，在C语言中应用什么实现，在C++中应用什么实现？
- C用宏定义，C++用inline
### 6.引用和指针的区别（重点）
- ① 引用必须被初始化，指针不必。所以说，不存在指向空值的引用，但存在指向空值的指针
- ② 引用相当于加了const的指针，即初始化后不能给改变
### 7.const 与 #define的比较，const有什么优点？
- ① const常量有数据类型、而宏常量没有数据类型。编译器可以对前者进行类型安全检查。后者只是文本替换，而且替换容易出现错误。
- ② 有些集成化的调试工具可以对const常量进行调试，但是不能对宏常量进行调试。

### 8.有了malloc/free 为什么还要new/delete？
- delete会调用对象的折构函数，和new对应free只能释放内存，new调用构造函数。
- malloc与free是C/C++的标准库函数，new/delete，像sizeof一样，是C++的运算符。它们都可用于申请动态内存的释放内存。
- 对于非内部数据类型的对象而言，光用malloc/free是无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行折构函数
- 由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和折构函数的任务强加于malloc/free。
- 因此C++语言需要一个能完成动态内存分配和初始化工作的运算符new，以及一个能够清理和释放内存工作的运算符delete。

### 9.如果在申请动态内存时找不到足够大的内存块，malloc和new将返回NULL指针，宣告内存申请失败。你是怎么处理内存耗尽的？
- ① 判断指针是否为NULL，如果是则马上用return语言终止本函数
- ② 判断指针是否为NULL，如果是则用exit(1)终止整个程序的指针。（exie(1) or exit(0)??）
- ③ 为new和malloc设置异常处理函数。例如Visual C++可以用_set_new_hander函数为new设置用户自己定义的异常处理函数。也可以让malloc与new使用相同的异常处理函数

### 10.宏定义、用法等等

### 11，
- 局部变量和全局变量可以重名吗？
- static，if not define
- 局部变量，全局变量，静态局部，静态全局


## 第二部分：类型和关键字
### 1.C++是不是类型安全的？
- 不是。两个不同类型的指针之间可以强制转换(用reinterpret cast)
### 2.const符号常量

### 3.delete与delete []区别
- delete只会调用一次折构函数，而delete[]会调用每一个成员的折构函数。在More Effective C++中有更为详细的解释：“当delete操作符用于数组是，它为每个数组元素调用折构函数，然后调用operator delete”来释放内存。"delete"与new配套，delete[] 与new[]配套
```C++
MemTest *mTest1 = new MemTest[10];
MemTest *mTest1 = new MemTest;
Int *pInt1 = new int [10];
Int *pInt2 = new int;

delete [] pInt1;  //  -1-
delete [] pInt2;  // -2-
delete [] mTest1;  // -3-
delete [] mTest2;  // -4-
```
- 在-4-出报错。
- 这就说明：对于简单数据类型，delete和delete[]功能是相同的。对于自定义的复杂数据类型，delete和delete[]不能互用。delete[] 删除一个数组，delete删除一个指针。
- 简单来说，用new分配的内存用delete删除；用new[]分配的内存用delet[]删除。delete[]会调用数组元素的折构函数。内部数据类型没有折构函数，所以问题不大。如果你再用delete时没有括号，delete就会认为指向的是单个对象。否则，就认为指向的是数组。

### 4.什么是“引用”？申明和使用“引用”要注意哪些问题？
- 引用就是某个目标变量的“别名”(alias)，对应用的操作与对变量直接操作效果完全相同。申明一个引用的时候，切记要对其进行初始化。引用声明完毕后，相当于目标变量名有两个名称，即该目标原名称和引用名，不能再把该引用名作为其他变量名的别名。声明一个引用，不是新定义了一个变量，它只表示该引用名是目标变量名的一个别名，它本身不是一种数据类型，因此引用本身不占存储单元，系统也不给引用分配存储单元。不能建立数组的引用。

### 5.将“引用”作为函数参数有哪些特点？
- （1）传递引用给函数与传递指针的效果是一样的。这时，被调函数的形参就成为原来主调函数中的实参变量或对象的一个别名来使用，所以在被调函数中对形参变量的操作就是对其相应的目标对象（在主调函数中）的操作。
- （2）使用引用传递函数的参数，在内存中并没有产生实参的副本，它是直接对实参操作；而使用一般变量传递函数的参数，当发生函数调用时，需要给形参分配存储单元，形参变量是实参变量的副本；如果传递的是对象，还将调用拷贝构造函数。因此，当参数传递的数据较大时，用引用比用一般变量传递参数的效率和所占空间都好。
-（3）使用指针作为函数的参数虽然也能达到与使用引用的效果，但是，在被调函数中同样要给形参分配存储单元，且需要重复使用"\*指针变量名"的形式进行运算，这很容易产生错误且程序的阅读性较差；另一方面，在主调函数的调用点处，必须用变量的地址作为实参。而引用更容易使用，更清晰。

### 6.在什么时候需要使用“常引用”？
- 如果既要利用引用提高程序的效率，又要保护传递给函数的数据不在函数中被改变，就应使用常引用。
- 常引用声明方式:``` const 类型标识符 &引用名 = 目标变量名; ```
```C++
// 例子1
int a;
const int &ra = a;
ra = 1;  // 错误
a = 1;  // 正确

// 例子2
string foo();
void bar(string &s);
// 那么下面的表达式将是非法的
bar(foo());
bar("hello world");
/*
原因在于:
在于foo( )和"hello world"串都会产生一个临时对象，而在C++中，这些临时对象都是const类型的。因此上面的表达式就是试图将一个const类型的对象转换为非const类型，这是非法的。引用型参数应该在能被定义为const的情况下，尽量定义为const 。
*/
```
### 7.将“引用”作为函数返回值的格式、好处和需要遵守的规则
### 8.结构和联合有什么区别？


## 第三部分：C++面向对象的特性
### 1.C++有哪些性质（面向对象特点）
- 封装，继承和多态
### [2.析构函数？](http://c.biancheng.net/view/152.html)
- 析构函数是成员函数的一种，它的名字与类名相同，但前面要加~，没有参数和返回值
- 一个类有且仅有一个析构函数。如果定义类时没写折构函数，则编译器默认生成折构函数。如果定义了折构函数，则编译器不生成默认析构函数。
- 析构函数在对象消亡时即自动被调用。可以定义析构函数在对象消亡前做善后工作。例如，对象如果在生产期间用new运算符动态分配了内存，则在各处写delete语句以确保程序的每条语句执行路径都能释放这片内存是比较麻烦的事情。有了析构函数，只要在析构函数中调用delete语句，就能确保对象运行中用new运算符分配的空间在对象消亡时被释放。
- 例如下面代码：
```C++
class String{
private:
    char* p;
public:
    String(int n);
    ~String();
};
String::~String(){
    delete[] p;
}
String::String(int n){
    p = new char[n];
}
```
- String类的成员变量p指向动态分配的一片存储空间，用于存放字符串。动态内存分配在折构函数中进行，而空间的释放在折构函数~String()中进行。这样，在其他地方就不用考虑释放空间的事情了。
只要对象消亡，就会引发折构函数的调用。
- 略

### 3.子类析构时要调用父类的析构函数吗？
- 析构函数调用的次序是先派生类的析构，然后是基类的析构。也就说，在基类的析构调用的时候，派生类的信息已经全部摧毁了。
- 定义个对象时先调用基类的构造函数、然后调用派生类的构造函数；
- 析构的时候恰好相反：先调用派生类的析构函数，然后调用基类的析构函数。

### 4.多态、虚函数、纯虚函数
- 多态：对于不同对象接收相同消息是产生不同动作。
- C++的多态性具体体现在运行和编译两个方面：
        - 在程序运行时的多态通过继承和虚函数来体现；
        - 在程序编译时多态性体现自函数和运算符的重载上；
- 虚函数：在基类中冠以关键字virtual的成员函数。它提供了一种接口界面。允许在派生类中对基类的虚函数重新定义。
- 纯虚函数的作用： 在基类中为其派生类保留一个函数的名字，以便派生类根据需要对它进行定义。作为接口而存在纯虚函数不具备函数的功能，一般不能直接被调用。
- 从基类继承来的纯虚函数，在派生类中仍是虚函数。如果一个类至少有一个纯虚函数，那么这个类被称为抽象类(abstract class)。
- 抽象类不仅包括纯虚函数，也可包括虚函数。抽象类必须用作派生类其他类的基类，而不能用于直接创建对象实例。但仍可使用抽闲累的指针支持运行时多态性。


## 第四 部分 内存
### 1.内存是如何分区的，存储什么内容？
- 程序代码区
- 常量区存放常量。程序结束时由OS回收。
- 全局区（静态区）存放全局变量和静态变量。初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。 程序结束时由OS回收。
- 堆区存放的变量（用new，malloc，calloc，realloc等分配内存函数得到的变量）由程序员分配释放。
- 栈区存放的变量（局部变量、函数参数等）由编译器自动分配释放。


## 第五部分：程序题
- 数据结构：DFS、BFS、排序、背会。
- 1.二叉树，二叉排序树，平衡二叉树，满二叉树的区别？  
- 2.邻接矩阵和邻接表  
- 3.选择排序和插入排序  

## 第六部分：项目+虚拟引擎+lua
- 大概介绍介绍自己项目
- 虚拟引擎的了解
- lua语言
